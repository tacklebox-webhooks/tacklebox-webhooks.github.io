<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="UTF-8" />
  <title>Tacklebox | Webhooks as a Service</title>

  <link rel="stylesheet" href="stylesheets/reset.css" />
  <link rel="stylesheet" href="stylesheets/main.css" />

  <link rel="apple-touch-icon" sizes="180x180" href="images/icons/favicons/graphic-red.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="images/icons/favicons/graphic-red.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="images/icons/favicons/graphic-red.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Display:ital,wght@0,400;0,700;0,900;1,400&display=swap"
    rel="stylesheet" />

  <script type="text/javascript" src="javascripts/sidebar.js"></script>
  <meta property="og:image" content="/images/logos/graphic-red.png" />
  <meta property="og:title" content="Tacklebox" />
  <meta property="og:description" content="An open-source serverless framework that offers webhooks as a
            service" />
</head>

<body>
  <header class="header-short">
    <nav>
      <ul>
        <li>
          <a href="index.html">
            <img src="images/logos/graphic-red.png" />
          </a>
        </li>
        <li>
          <a href="index.html">Home</a>
        </li>
        <li><a href="case-study.html" class="active">Case Study</a></li>
        <li><a href="team.html">Our Team</a></li>
        <li class="flex-float-right">
          <a href="https://github.com/tacklebox-webhooks/cli" target="_blank">
            <img src="images/logos/github-mark-light.png" alt="Tacklebox GitHub" class="github" />
          </a>
        </li>
      </ul>
    </nav>
  </header>

  <div class="study-wrapper">
    <aside class="sidebar">
      <ul>
        <li>
          <a href="#Introduction"> 1. Introduction</a>
        </li>
        <li>
          <a href="#IntroToWebhooks"> 2. Intro to Webhooks</a>
        </li>
        <li>
          <a href="#BuildingWebhooks">
            3. Building Webhooks Is Not Trivial</a>
        </li>
        <li>
          <a href="#ExistingSolutions"> 4. Existing Solutions</a>
        </li>
        <li>
          <a href="#UsingTacklebox"> 5. How to Use Tacklebox</a>
        </li>
        <li>
          <a href="#BuildingTacklebox"> 6. How We Built Tacklebox</a>
        </li>
        <li>
          <a href="#FutureWork"> 7. Future Work</a>
        </li>
        <li>
          <a href="#References"> 8. References</a>
        </li>
      </ul>
    </aside>

    <main>
      <section id="case-study">
        <h1>Case Study</h1>
        <h2 id="Introduction">1. Introduction</h2>
        <p>
          An event-driven architecture is a programming paradigm that involves
          producing, detecting, consuming, and reacting to events.
        </p>
        <p>
          Webhooks represent an event-driven approach to web development.
          Data about events is sent to web applications, and these web apps
          can react to these events accordingly.<sup class="footnote-ref"><a
          href="#fn1" id="fnref1">[1]</a></sup>
        </p>
        <p>
          Tacklebox is an open-source serverless framework that offers webhooks
          as a service. Now, don't worry if that seems like a mouthful, because
          it is, so we'll try to unpack the meaning behind that phrase throughout
          this case study.
        </p>
        <p>
          Tacklebox includes four components:
<!--           
          <ul>
            <li>a <a href="https://github.com/tacklebox-webhooks/cli">CLI tool</a></li>
            <li>a management UI</li>
            <li>
              4 client libraries
              (<a href="https://github.com/tacklebox-webhooks/javascript">JavaScript</a>,
              <a href="https://github.com/tacklebox-webhooks/ruby">Ruby</a>,
              <a href="https://github.com/tacklebox-webhooks/python">Python</a> and
              <a href="https://github.com/tacklebox-webhooks/golang">Go</a>)
            </li>
            <li>
              a webhooks service which comprises:
              <ul>
                <li>a RESTful API</li>
                <li>AWS infrastructure</li>
              </ul>
            </li>
          </ul> -->
        </p>

        <div id="tacklebox-components" class="img-wrapper">
          <img src="images/newDiagrams/tackleboxComponents.png" alt="Tacklebox Components" />
        </div>
        
    
        <h2 id="IntroToWebhooks">2. Intro to Webhooks</h2>

        <h3 id="What-are-webhooks">2.1. What are webhooks?</h3>
        
        <p>
          To understand what webhooks are, let’s begin with an example using a
          tool we all know: GitHub. Imagine that you are part of a team, that you
          have one repo for the project the team will work on, and that you want
          to do something programmatically when a branch is created by a teammate,
          like for example, post a message on Slack or something like that.
        </p>
        <p>
          The flow would look something like this:
          <ol>
            <li>One of your teammates creates a new branch locally.</li>
            <li>The change is pushed to the repo.</li>
            <li>The branch is actually created on the repo.</li>
            <li>You want to do something programmatically as a result of this
              branch creation.</li>
          </ol>
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/consumerFlow.png" alt="Consumer Webhook Flow" />
        </div>
        <p>
          So the question then becomes, how can you automate what you want to
          do once the event happens, which in this case, is a branch being
          created? You basically have two options: Polling and Webhooks.
        </p>
        <p>
          In the context of Web APIs, the party interested in data (which in
          this case, it's you) is called the consumer, and the party that
          provides the data of interest (which in this case, it's GitHub) is
          called the provider.<sup class="footnote-ref"><a href="#fn2"
          id="fnref2">[2]</a></sup>
        </p>
        
        <h4 id="Polling">2.1.1. Polling</h4>
        
        <p>
          With polling, you basically send and HTTP request to GitHub every so
          often to see if there's any updates. In this case, you happen to
          send a couple requests first with no updates from GitHub, and then a
          third one where there's an update.<sup class="footnote-ref"><a href="#fn3"
          id="fnref3">[3]</a></sup>
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/polling.png" alt="General Polling Workflow" />
        </div>
        
        <h4 id="Webhooks">2.1.2. Webhooks</h4>
        
        <p>
          With webhooks, however, instead of having GitHub wait for incoming
          requests in order to handle them, now GitHub proactively sends an
          HTTP request to you every time an event you care about occurs. To be
          more specific, GitHub sends an HTTP request every time something of
          interest happens to a URL that you register with them.
          <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/webhooks.png" alt="General Webhook Workflow" />
        </div>
        <p>
          In this particular case, a branch was created, so GitHub sends an
          HTTP request to your endpoint, and you then acknowledge the request.
          In other words, a webhook is nothing more than an HTTP request sent
          when an event happens.
        </p>
        <p>
          Up to this point, we have only talked about webhooks from the
          perspective of the consumer. Now, let's switch gears a little bit to
          talk about webhooks but from the perspective of the provider, which
          in the example was GitHub. In other words, let's put ourselves in
          GitHub's shoes.
        </p>
        <p>
          Following the same example, if we're GitHub, and a consumer is
          interested in receiving a webhook every time a branch is created,
          the workflow would look something like this:
          <ol>
            <li>
              You receive a subscription request with a URL to send webhooks to, which
              would be the URL on the right of the diagram below (https://sendrequestshere.io).
              This subscription request also specifies the event type that the consumer
              cares about, which in this case is a branch creation.
            </li>
            <li>You persist the subscription</li>
        <div class="img-wrapper">
          <img src="images/newDiagrams/providerFlow1.png" alt="Provider Webhook Flow 1" />
        </div>

            <li>A branch is created at some point in time</li>
            <li>
              You check to see who is subscribed to that event type since
              there may be more interested parties.
            <li>
              You send a webhook to the URL of each consumer subscribed to that
              particular event type, which in this case, for simplicity's sake, is
              just the consumer from step one.
            </li>

        <div class="img-wrapper">
          <img src="images/newDiagrams/providerFlow2.png" alt="Provider Webhook Flow 2" />
        </div>
          </ol>
        </p>
        <p>
          To show you how webhooks look like in real applications, here's a
          screenshot of the UI GitHub offers for webhooks. Up to the right,
          you can see an "add" button which would be used to request a
          subscription.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/githubExample1.png" alt="What are webhooks" />
        </div>
        <p>
          After clicking that button, you get to the page where you specify
          the URL where you want to receive webhooks, the event type you're
          interested in, among other things.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/githubExample2.png" alt="What are webhooks" />
        </div>
        <p>
          And once you register a URL to receive webhooks, you can see all the
          webhooks that GitHub has sent you, their headers, their payload, etc.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/githubExample3.png" alt="What are webhooks" />
        </div>

        <h3 id="Who-uses-webhooks">2.2. Who uses webhooks?</h3>

        <p>
          So far, when talking about webhooks, we've only talked about GitHub.
          However, it turns out that GitHub is not the only company that
          offers webhooks. Some examples of companies that also offer webhooks are:
          <ul>
            <li>Stripe, which can send you a webhook when for example a payment
              is processed.<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]
              </a></sup></li>
            <li>Twitter, which can send you a webhook when for example you
              receive a direct message.<sup class="footnote-ref"><a href="#fn6"
              id="fnref6">[6]</a></sup></li>
            <li>Intuit, the company that owns products like TurboTax and QuickBooks,
              which can send you a webhook when for example a budget is created.
              <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></li>
          </ul>
        <p>
          And we can keep going. The point is, webhooks are everywhere.
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/webhookCompanies.png" alt="Companies That Provide Webhooks" />
        </div>

        <h3 id="Pros-and-Cons-of-building-webhooks">

          2.3. Pros and Cons of building webhooks
        </h3>
        <p>
          Now that we have some context around webhooks, we can start talking
          about things to consider when building them. As a provider, webhooks 
          offer a few benefits. For example:
          <ul>
            <li>You can provide a better experience to your users that
              want or need webhooks.</li>
            <li>You can lower the amount of requests your infrastructure needs
              to handle over time.</li>
          </ul>
        </p>
        <p>
          However, webhooks are not perfect:
          <ul>
            <li>
              If you want a very simple webhooks implementation, it may not
              take you too long. However, if you want a robust implementation,
              you have to spend a lot of time and effort building it.
            </li>
            <li>
              And the reason you have to spend a lot of time and effort building
              webhooks well is because building webhooks well is not easy.
            </li>
          </ul>
        </p>
        <p>
          We're going to talk about why building webhooks well is not easy
          in the next section.
        </p>

        <h2 id="BuildingWebhooks">
          3. Building Webhooks Is Not Trivial
        </h2>

        <h3 id="Considerations-when-building-webhooks">

          3.1. Considerations when building webhooks
        </h3>
        <p>
          Now you, the provider, want to build webhooks in your app. However,
          implementing webhooks well is not as trivial as it may seem at first
          glance. Since we can go down a rabbit hole here, we decided to talk
          about 4 different areas or categories that may present a significant
          amount of challenges.
        </p>
        <h4 id="First-consideration">

          3.1.1. Endpoint Failure
        </h4>
        <p>
          The first area that comes to mind when thinking about building webhooks
          is failed messages or endpoint failure. For example:
          <ul>
            <li>What happens if a consumer URL endpoint fails or is unreachable?</li>
            <li>Do you try to send the message again?</li>
            <li>And if you do, how often and how many times do you retry before
              you stop?</li>
          </ul>
        </p>
        <h4 id="Second-consideration">

          3.1.2. Security and Authentication
        </h4>
        <p>
          The second area that comes to mind is security and authentication. For instance:
          <ul>
            <li>Do you want to make sure the appropriate consumer controls an endpoint
              before you send messages to it?</li>
            <li>How do you allow consumers to verify the integrity of messages?</li>
            <li>How about allowing them to verify the origin of messages?</li>
          </ul>
        </p>
        <h4 id="Third-consideration">

          3.1.3. Monitoring
        </h4>
        <p>
          The third area revolves around monitoring. For example:
          <ul>
            <li>How do you identify frequently failing endpoints?</li>
            <li>How do you monitor historical usage patterns?</li>
          </ul>
        </p>
        <h4 id="Fourth-consideration">

          3.1.4. Consumer Experience
        </h4>
        <p>
          And last but not least, we have the area of consumer experience. For instance:
          <ul>
            <li>Do you want to allow your consumers to manually trigger events for
              testing and other purposes?</li>
            <li>For example, aside from testing, do you want to allow them to resend
            a message manually?</li>
            <li>And if you do, how would you implement that?</li>
          </ul>
        </p>

        <h3 id="Building-webhooks-for-a-single-application">

          3.2. Building webhooks for a single application
        </h3>
        <p>
          In the simplest scenario, building webhooks in one app would look
          something like this. For simplicity, you have two consumers, but
          there could be more. All these concerns you have would fall into this
          new webhook implementation in this single app.
        </p>
        <p>
          The numbered red circles inside the app represent the four areas of
          concern mentioned in the previous section.
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/singleApp.png" alt="Single App Webhook Considerations" />
        </div>

        <h3 id="Building-webhooks-for-multiple-applications">

          3.3. Building webhooks for multiple applications
        </h3>
        <p>
          But what if you need webhooks in more than one app? If you implement
          webhooks in more than one app, it would look something like this.
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/multipleApps.png" alt="Multi App Webhook Considerations" />
        </div>
        <p>
          Now, you have all the concerns from before times the number of apps.
          And on top of that, more questions come up in this scenario. For
          example:
          <ul>
            <li>How do you avoid redundant work while implementing and
              maintaining webhooks across all your apps?</li>
            <li>How do you make sure that webhooks are consistent across all your apps?</li>
            <li>Is governance or compliance critical to your apps? And if so, how do
              you enforce control over your data?</li>
          </ul>
        </p>

        <h3 id="Extracting-webhooks-into-a-service">

          3.4. Extracting webhooks into a service
        </h3>
        <p>
          At this point, the need for building a robust webhooks
          implementation as its own service becomes clear.
        </p>
        <div class="img-wrapper">
          <img src="images/newDiagrams/serviceExtraction.png" alt="Extracted Webhook Service" />
        </div>
        <p>
          Now, all these concerns are abstracted away by this service, and
          this would give you many benefits. For example:
          <ul>
            <li>You would have a single place to maintain code and add features</li>
            <li>You would have a single place to monitor the service performance
              and other metrics</li>
            <li>You would have one place where to manage related infrastructure</li>
            <li>You could have consistency across all the apps</li>
            <li>Now the apps don’t have to be aware of who is consuming their webhooks,
              allowing more focus on business logic</li>
            <li>Now we would have centralized control over data in order to enforce
            governance or compliance if those are important for your apps</li>
          </ul>
        </p>

        <h2 id="ExistingSolutions">4. Existing Solutions</h2>

        <p>
          If you’re thinking about implementing a webhooks solution
          yourself, the question that naturally arises is “how do I do that?”.
          As we saw earlier, many companies have already
          implemented their own in-house solution and posted their learnings
          online so there are quite a few blueprints out there.
          <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>
        </p>

        <h3 id="In-HouseSolutions">4.1. In-House Solutions</h3>

        <p>
          We took particular inspiration from how Square went about
          implementing this feature themselves. They decided to go with AWS
          because it offered the simplest solution thanks to a new feature
          that allowed them to configure Lambdas to pull from Simple Queue
          Service automatically. Some other key features that we liked are: -
          how they used a queue for messages waiting to be sent to subscribers
          - how they used lambdas to dequeue messages and send them to
          subscribers - and how they went about storing successful or failed
          messages in a separate queue or database<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/square.png" alt="Square Webhook Implementation" />
        </div>

        <p>
          We also liked Wise Engineering’s webhook service implementation.
          They utilized the SNS (Simple Notification Service) AWS service to
          handle consumer subscriptions.  Specifically, SNS handled figuring out which subscriptions needed to be notified when an event happened, sending those notifications to subscribing endpoints, and handling the retry logic for failed messages. Because SNS handles those operations, they could be extracted from the main app logic.<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/wiseEngineering.png" alt="Wise Engineering Webhook Implementation" />
        </div>

        <h3 id="Commercial-and-Open-Source">
          4.2. Commercial and Open Source
        </h3>

        <p>
          As mentioned above, trying to build webhooks and
          integrate them even in just one app can be very complex, so as you
          think about trying to expand that out to multiple different apps in
          your ecosystem that can be a very difficult and time consuming thing
          to do.
        </p>

        <p>
          Let’s say for instance that you decide that you don’t want to
          do that because of the complexity and you’d rather off load that to
          a 3rd party provider. Generally, you would have two options, either
          a commercial solution or an open source solution. Unfortunately,
          there currently isn’t an open source solution that provides webhooks
          as a service so that bring us back to considering building a
          solution in-house instead. If you decide to go the commercial route,
          there are a couple of companies that offer Webhooks as a Service.
        </p>

        <p>
          The general workflow when using the commercial solutions would be as
          follows: - You, the provider, communicate with their service via API
          calls to set up subscriptions, create event types, send messages
          when an event is triggered, and access message history.<sup class="footnote-ref"><a href="#fn8"
              id="fnref8">[8]</a></sup>
        </p>

        <h3 id="commercial-vs-diy">4.3. Commercial vs. DIY</h3>

        <p>
          The commercial solutions handle the data storage, message sending
          processes to your consumers and general infrastructure management. -
          The trade offs that arise when using commercial solutions would be
          the fact that’d you’d be sharing data with a third party vendor and
          there would be a lack of software customization because it isn’t
          open source. As we saw earlier there are a number of large existing
          companies that offer webhooks to their customers like Github,
          Stripe, Twitter, and Square. They had to build their own solutions
          in-house and manage their own infrastructure but by accepting those
          trade offs, they were able to have control of their data and
          customize their solution to better suit their business needs as they
          change. By examining the pros and cons of each approach we set out
          to create an open source framework that’s easy to deploy and manage.
          And that’s where Tacklebox comes into play.
        </p>

        <div id="comparison-table" class="img-wrapper">
          <img src="images/newDiagrams/comparisonTable.png" alt="Commercial vs. DIY vs. Tacklebox" />
        </div>

        <h3 id="Tacklebox-use-case">4.4. Tacklebox use case</h3>

        <p>
          So who is Tacklebox geared toward? A good way to find out is to ask
          yourself these 4 questions.
        </p>

        <ul>
          <li>
            Do you want to be able to easily integrate this feature across multiple applications?
          </li>
          <li>
            Do you want to have control over your data?
          </li>
          <li>
            Are you a small to medium size application.
          </li>
          <li>
            Is your applications core competency anything but webhooks?
          </li>
        </ul>
          
        <p>
          If you answered yes to all of the above questions, then
          Tacklebox would likely be a good fit for you.
        </p>

        <h2 id="UsingTacklebox">5. How to use Tacklebox</h2>

        <h3 id="Project-Goals">5.1. Project Goals</h3>

        <p>
          Tacklebox had three main goals from the outset:
        </p>

        <ul>
          <li>
            Make it easy to provide webhooks across multiple applications.
          </li>
          <li>
            Make it easy to deploy and manage its infrastructure
          </li>
          <li>
            Make it easy to integrate with an application
          </li>
        </ul>

        <h3 id="Deployment">5.2. Deployment</h3>

        <p>
          To realize the goal of easy deployment, we created our service in
          such a way that deployment is abstracted to one simple command: "tacklebox deploy".
        </p>

        <div class="img-wrapper">
          <img src="images/gifs/deploy.gif" alt="Deployment" />
        </div>

        <p>
          At a high level, this process involves pulling in the code necessary to create a CloudFormation template, spinning up AWS infrastructure based on that template, setting AWS permissions so every infrastructure piece is able to properly communicate with the others, building the UI, and pre-populating the Tacklebox database with necessary tables.  This command abstracts away quite a few steps that a webhook provider would typically have to do on their own, and the scope of the process is reflected in the amount of time it takes to complete, which is typically around 20 minutes (it's been sped up in the gif above for demonstration purposes).
        </p>

        <p>
          When this command is finished, Tacklebox is ready to use.  The output of the deployment has two parts: first, the API Host, which is the Base
          URL you'll use to communicate with the Tacklebox API; and second, the API Key, which is the key the Tacklebox API uses to authenticate you. These two pieces of information are all you need to make calls to the Tacklebox API or use our client libraries, and you don't have to leave your CLI to retrieve them.
        </p>

        

        <h3 id="UI">5.3. UI</h3>

        <p>
          After running tacklebox deploy, you can run the management UI on
          your local server with one command: tacklebox ui.
        </p>

        <div class="img-wrapper">
          <img src="images/gifs/ui.gif" alt="DeployUI" />
        </div>

        <p>
          This management UI
          ties back to making it easy to provide webhooks across multiple
          applications. Instead of having to make API calls to figure out the
          KPIs of your webhooks feature for one of your apps, you can just
          view it all in a convenient dashboard
        </p>

        <div class="img-wrapper">
          <img src="images/diagrams/uiDash.png" />
        </div>

        <h3 id="Client-libraries">5.4. Client libraries</h3>

        <p>
          To make our framework even easier to manage across your apps, we
          provided client libraries in 4 languages: Ruby, GoLang, JavaScript, and Python.  As mentioned above, in order to use them you only need to have your API Host URL and API Key.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/clientLibraries.png" />
        </div>

        <h3 id="Tacklebox-Demo">5.5. Tacklebox Demo</h3>
        <p>
          Imagine that you’re a software engineer at a consumer electronics
          company and you’re tasked with enabling automatic notifications from
          your purchase order app to several other supply chain apps.  You'd like to use Tacklebox to notify the supply chain apps when certain events in the purchase order app occur.  In other words, the purchase order app is going to be providing webhooks via Tacklebox.
        </p>

        <p>
          First you would create a new service in Tacklebox that represents the app that will be providing webhooks, which in this case is the purchase order app.  We're choosing to do this with direct API calls in this and the following steps, however as mentioned above you can also use one of our client libraries programatically.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDemoGif.png" />
        </div>

        <p>
          After creating a service, you'd then add event types to that service, which represent certain events that can occur in that service.  In this case, we want notifications to be sent whenever a purchase order is created, so we create an "order created" event type.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDemoGif.png" />
        </div>

        <p>
          Now that your service has event types, you'd need to create users, which in this case represent the other supply chain apps that want to be notified when a purchase order is created.  Users represent apps or entities that will be consuming webhooks.  As such, they can be utilized in a few different ways depending on your use case.  For Github, users are repositories. For a todo app, users might be the owner of a todo list.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDemoGif.png" />
        </div>

        <p>
          At this point you've got a service, its event types, and a few users.  You would now need to add subscriptions, which represent a url and the event types it should receive notifications about.  Users must have at least one subscription to receive webhook notifications, however they are not restricted to one subscription and can have many for different purposes.  In this case the InvoiceApp only cares about being notified when a purchase order
          is generated, so that is the only event type that we list here.
        </p>
        
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDemoGif.png" />
        </div>

        <p>
          We can check our UI to see what we've created so far. As shown below, we've currently got once service (OrderApp), one user, and one subscription.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDashGif.png" />
        </div>

        <p>
          Now that you've got all of your setup done, your purchase order app is ready to start sending webhook notifications (and its users are ready to start consuming them).  When a purchase order for 5 computers is created, this triggers a message to be sent to the subscribing endpoints which can then view the webhook content and take action accordingly.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeEventTriggerGif.png" />
        </div>

        <p>
          Moving back to our management dashboard after the triggered event,
          we can see the corresponding data has updated accordingly with one event
          being triggered and one message being sent. From here, we are also
          able to view more granular details about the recently triggered
          event as well as the corresponding message that was sent.
        </p>
        <div class="img-wrapper">
          <img src="images/diagrams/shouldBeDashGif.png" />
        </div>

        <h3 id="Teardown">5.6. Teardown</h3>

        <p>
          If you decide that you no longer need Tacklebox, you
          can simply remove it with one simple command,
          “tacklebox destroy”.  Because Tacklebox allows you to provide webhooks for multiple applications at once, it is important to note that the tacklebox destroy command tears down the infrastructure for the entire webhook service, not just a single app.
        </p>
        <div class="img-wrapper">
          <img src="images/gifs/destroy.gif" />
        </div>

        <h2 id="BuildingTacklebox">6. How we built Tacklebox</h2>
        <p>
          In this section, we will explore how we built Tacklebox, and some of the implementation decisions we made
          along the way.
        </p>
        <h3 id="Webhook-feature-requirements">6.1. Webhook feature requirements</h3>

        <p>
          Before we can talk about the Tacklebox architecture, it’s important to understand the feature requirements for
          a webhook service.
          Since consolidation is a key part of our use-case, allowing multiple applications to use Tacklebox
          simultaneously was important to us. Additionally, we wanted to allow providers to specify event types when
          setting up their webhook service. Recalling the Github example, their webhooks feature would be less useful if
          their users received notifications for all types of events, rather than being able to select a subset.
          Allowing granular control over event types is important.
          Next, we wanted to provide easy access to message history. This includes two distinct parts: persisting every
          message sent by Tacklebox (along with delivery statuses), and providing an interface to view that message
          history.
          Finally, we wanted to send messages to consumers when events occur. Again, this is the central piece of
          Tacklebox. Without this, it is not a webhook service.
        </p>

        <h3 id="tacklebox-architecture">6.2. Tacklebox Architecture</h3>

        <h4>Architecture Overview</h4>

        <div class="img-wrapper">
          <img src="images/newDiagrams/finalArchitecture.png" alt="Final Tacklebox Architecture" />
        </div>

        <p>
          In our architecture, notification intake is handled by a pair of services: API Gateway and Lambda Functions.
          API Gateway serves as the entry point into Tacklebox, and passes incoming notifications to an intake Lambda.
          The next two steps in the life cycle, gathering consumers and sending messages, are handled by the Simple
          Notification Service.
        </p>
        <p>
          The last step, saving messages to the database, is taken care of by a combination of a log service, CloudWatch
          Logs, and a lambda that transfers message information from the logs to our database.
        </p>

        <h4>Event/Message Lifecycle</h4>

        <p>
          The core functionality of a webhook service is sending messages to endpoints when events occur. That process
          might include the following steps:
        </p>

        <ul>
          <li>
            <p>
              An event occurs in an application, and that application notifies the webhook service.
            </p>
          </li>
          <li>
            <p>
              The webhook service looks at the event type, and gathers a list of subscribers that need to be notified.
            </p>
          </li>
          <li>
            <p>
              The webhook service sends a message to every valid subscriber letting them know that an event has
              occurred.
              If any message delivery fails, the webhook service attempts to resend the message until it succeeds or
              reaches a set number of attempts.
            </p>
          </li>
          <li>
            <p>
              Each message and its result gets saved to the database, regardless of whether it was successful or not.
            </p>
          </li>
        </ul>

        <div class="img-wrapper">
          <img src="images/newDiagrams/eventLifecycleOverArchitecture.png" alt="Event Message Lifecycle" />
        </div>

        <h4>CRUD Operations</h4>

        <p>
          Even though we are going to be focusing almost exclusively on the event/message lifecycle as we discuss our
          architecture moving forward, our architecture also tracks additional entities in the database, such as
          applications, users, and event types. Generally speaking, almost all of our CRUD operations are handled by our
          intake lambda, which communicates directly with the database as needed. Because of our focus on the
          event/message lifecycle, we’re going to call our database the “message history” moving forward, but this is
          really a store for all persistent data, including applications, users, event types, etc. There are a few
          processes that require interacting with both the database and SNS, like creating or updating a subscription,
          and in those cases the lambda orchestrates the process.
        </p>
        <p>
          Database operations within Tacklebox fall into two categories: workflows which involve SNS, and ones that do
          not involve SNS. The non-SNS operations are much more simple, and involve fewer pieces of the Tacklebox
          infrastructure. In these cases, the intake lambda, upon receiving a request from API Gateway, interacts with
          the database directly.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/addUserOverArchitecture.png" alt="Add User Workflow" />
        </div>

        <div class="img-wrapper">
          <img src="images/newDiagrams/addSubscriptionOverArchitecture.png" alt="Add Subscription Workflow" />
        </div>

        <h4>Database Choice</h4>

        <p>
          Before we move into the next section to talk about the evolution of our architecture and the challenges we
          solved along the way, we'd like to briefly discuss our choice of database.
        </p>

        <p>
          Webhook data seems, at first glance, inherently unstructured. Webhooks have a wide range of real-world
          applications, and each application dictates the kind of information passed back and forth between webhook
          provider and webhook consumer. An open-source webhook service needs to be flexible enough to handle many of
          those applications, so having a database that could adapt to meet those needs seemed important.
        </p>

        <p>
          This initially led us to consider NoSQL databases due to their strength handling schemaless data. Because we
          were using AWS infrastructure, the most likely candidate became their DynamoDB service. DynamoDB certainly had
          its advantages:
        </p>

        <p>
        <ul>
          <li>
            <p>
              It's fully managed so our users wouldn't have to maintain it
            </p>
          </li>
          <li>
            <p>
              It's designed to be highly available, and that property could be an asset during times when a large volume
              of events are coming in.
            </p>
          </li>
          <li>
            <p>
              It offers a feature called "Streams" which you can integrate with lambda functions to automatically run
              code when a record is added, updated, or deleted.
            </p>
          </li>
        </ul>
        </p>

        <p>
          The more we considered this, however, the more we realized that webhook data as a whole is actually quite
          predictable and structured. Entities like users, events, messages, and subscriptions share common
          characteristics across webhook implementations. In fact, the only piece of data related to webhooks that is
          really quite different across implementations is the payload that gets delivered to the consumer when an event
          occurs. We would certainly need to be able to handle a range of payloads, but even those have high-level
          similarities, and most can be represented by a JSON object.
        </p>

        <p>
          The following Entity Relationship Diagram shows how we ended up structuring our data. We used the jsonb data
          type for our payload field in the events table, which allows us to store normal JSON objects efficiently.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/erd.png" alt="Tacklebox ERD" />
        </div>

        <p>
          Most of the features we'd be trading off by going with PostgreSQL instead of DynamoDB were ones our use case
          didn't really demand - specifically built for high availability, schemaless, and able to support tables of
          virtually any size and very high read/write traffic. The one thing we didn't want to lose was the fact that
          DynamoDB is fully managed, which was key to our project goal of making Tacklebox easy to deploy and manage.
        </p>

        <p>
          Amazon's Relational Database Service (RDS) allowed us to retain most of that benefit. It's not quite as
          hands-off as DynamoDB when it comes to things like scaling, however it comes close regarding overall
          maintenance. RDS handles the hosting, provisioning, and patching of the database, and it allowed us to use
          PostgreSQL as the actual database, which is widely used and reliable.
        </p>

        <p>
          In the end, both DynamoDB and RDS w/ PostgreSQL would have worked in our implementation, but our use case
          didn't really take advantage of DynamoDB's strengths, so we chose RDS w/ PostgreSQL.
        </p>

        <h3 id="Challenges">6.4. How we dealt with wasted uptime</h3>

        <h4>Initial Implementation</h4>

        <p>
          Our initial implementation of Tacklebox used a single application server.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/serverImplementation.png" alt="Basic Server Implementation" />
        </div>

        <p>
          This approach worked for our use-case, but we saw an opportunity to optimize our infrastructure. Webhooks
          usage patterns are often unpredictable and can have moments of high-use as well as periods of minimal usage. As a result, with this single app server architecture, we were leaving a decent amount of compute power unused.  To address this inefficiency, we decided to use AWS Lambda Functions.
        </p>

        <h4>Lambda Implementation</h4>

        <p>
          Lambda functions, which are a “Function as a Service” offering from AWS, allow us to only run code when
          needed.  This also means that you only pay for the compute that you actually need. 
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/lambdaImplementation.png" alt="Lambda Implementation" />
        </div>

        <p>
          As with any service, lambdas come with tradeoffs:
        </p>

        <ul>
          <li>First of all, cold start times can increase latency (cold start time refers to the time that it takes to
            load the function into memory before it can be invoked)</li>
          <!-- [https://lumigo.io/blog/this-is-all-you-need-to-know-about-lambda-cold-starts/] -->
          <li>Lambdas are stateless, so accessing persistent data requires a call to another service</li>
          <!-- [https://aws.amazon.com/lambda/faqs/#AWS_Lambda_functions] -->
          <li>Lambdas have an execution time limit - currently this is set to 15 minutes.</li>
          <!-- [https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html] -->
        </ul>

        <p>
          We found these tradeoffs acceptable for Tacklebox. Going with lambdas, though, meant that each lambda would
          have to do all of the following tasks every time it runs:
        </p>

        <ul>
          <li>Intake a new event and persist it to the database</li>
          <li>Gather subscriptions and create messages for each subscriber</li>
          <li>Send messages to all subscribers and wait for their responses</li>
          <li>Write responses to the database</li>
          <li>Respond back to the event producer</li>
        </ul>

        <h3 id="Message Fanout">6.4. How we handled message fanout</h3>

        <h4>Message Fanout Process</h4>

        <p>
          With this implementation, the message fanout process in particular
          is expensive. When an event comes in a lambda function gets fired up
          and creates a list of messages that need to be sent to each consumer
          listening for that event type.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/lambdaFanout.png" alt="Lambda Message Fanout" />
        </div>

        <p>
          The lambda not only has to send the messages, but also has to wait
          for a response from every one before it can finish its work by
          writing the results to the database. Because webhooks are
          typically application or user-specific, the number of consumers
          needing to be notified when a given event occurs is typically low,
          however even with tens of consumers the chance that one of the
          consumer’s endpoints will fail over time increases.
          <!-- Insert citation for DDIA pg. 278 here -->
        </p>

        <h4>Message Retries</h4>

        <p>
          When a message fails to be delivered successfully, the burden of
          resending still lies with the same lambda. It can't save the results
          of any of the messages it delivered until all of the retries are
          also done. We chose to implement our retry logic with an exponential
          backoff, which is a common algorithm that increases the amount of
          time between successive retries. This means that not only might a
          lambda have to wait for multiple retries to finish, the amount of
          time between retries is going to increase every time. We originally
          chose to use lambdas to reduce unusued uptime, and having a lambda
          function running for minutes at a time just waiting to run the next
          retry was contrary to that decision.
        </p>

        <div class="img-wrapper">
          <img src="images/newGifs/messageRetries.gif" alt="Retrying Failed Messages" />
        </div>

        <h4>Endpoint Failure</h4>

        <p>
          A quick note about endpoint failure and what that means in the
          context of Tacklebox and webhooks in general. An HTTP response to a
          webhook request typically falls into two general categories - you
          either get a response from the consumer or you don't (i.e. a
          timeout). At minimum, we need to know that a consumer's endpoint
          received the message, so we consider timeouts within a reasonable
          amount of time to be failures.
        </p>
          <!-- amount of time to be failures. When you do receive an explicit
          response from a consumer, though, a few questions arise:
        </p>

        <ul>
          <li>
            <p>
              Do we consider a response status from 300-399 a failure? If not,
              do we follow the redirects until we get to a 200-299 response?
              How many redirects do we follow if there are multiple?
            </p>
          </li>
          <li>
            <p>Do we consider a response status from 400-499 a failure?</p>
          </li>
          <li>
            <p>
              Do we consider a response status from 500-599 a failure? If not,
              how do we know if we should send another message? The consumer's
              endpoint could have failed before or after it actually processed
              the message, and we'd have no way to tell.
            </p>
          </li>
        </ul> -->

        <!-- <p>
          From a webhook provider's perspective, the question for any given -->
        <p>
          When you do receive an explicit response and are considering the status code, you must determine whether it indicates the consumer received the
          message and whether it makes sense to try sending the message
          again. Repeatedly sending messages to endpoints that are
          misconfigured by the consumer, for example, may not make sense. Existing webhook
          implementations approach this in a wide variety of ways, from
          strictly requiring a 200 response to considering anything other than
          a 5xx response a success. We chose the latter approach.
        </p>

        <h4>Split-Lambda Implementation</h4>

        <p>
          In order to reduce the number of messages our lambdas had to send,
          we could have done a couple of things. We could have added a second
          type of lambda, which we’ll call a messenger lambda, which would
          have allowed us to separate the message creating and message sending
          processes. With this approach, when an event comes in, our intake
          lambda gathers the list of consumers that need messages and calls a
          separate messenger lambda to send each message. This way, our
          messenger lambdas can all run at the same time and don’t have to
          wait for each other to finish.
        </p>

        <div class="img-wrapper">
          <img src="images/newGifs/doubleLambdaFanout.gif" alt="Double Lambda Fanout" />
        </div>

        <p>
          Retries would be difficult to implement with this approach though -
          where would we put messages that need to be retried? We could keep
          the intake lambda running until all of the messenger lambdas finish,
          so that if one fails it could spin up a new messenger lambda for the
          retry, but then the intake lambda would again be waiting for all
          retries to finish which we don't want. We could have also
          potentially put outgoing messages in the database, but that’s a lot
          of writing, reading, and deleting for temporary data.
        </p>

        <p>
          We ideally wanted somewhere we could buffer our outgoing messages,
          and have a mechanism to quickly pull them off in-order. That’s
          exactly what a queue does, and a queue would have the added benefit
          of centralizing our entire outgoing message list into one place,
          which simplifies debugging.
        </p>

        <h4>SQS Implementation</h4>

        <p>
          Amazon’s Simple Queue Service, or SQS for short, does exactly this.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/sqsFanout.png" alt="SQS Message Fanout" />
        </div>

        <p>
          SQS gives us a reliable place to store both our initial and retry messages, which allows our intake lambdas to just focus on creating messages for an event. SQS doesn’t send messages to consumers itself, so we use our messenger lambdas to pull messages off as soon as they appear and send them to the consumer.  To prevent our messenger lambdas from waiting on retries, we have them immediately put failed messages back into the queue. Those failed messages are then picked off of the queue by a different lambda invocation at a later time.
        </p>

        <p>
          By adding SQS we increased the complexity of our implementation, but each piece does fewer things and we sufficiently separated our concerns among services suited for their individual jobs.
        </p>

        <h4>Eliminating Polling</h4>

        <p>
          We thought that this was a perfectly reasonable implementation, however we wondered if we could eliminate, ironically enough for a webhook service, the polling in our architecture. Our messenger lambdas use polling to constantly check SQS to see if new messages have been added. As we’ve mentioned, webhook events can be intermittent, and all of those polling requests in between events can add up.
        </p>

        <div class="img-wrapper">
          <img src="images/newGifs/lasers.gif" alt="SQS Lamba Polling" />
        </div>

        <p>
          Under the hood it gets even more interesting, because when using
          lambdas with SQS, Amazon requires that a minimum of 5 parallel
          lambdas poll SQS, so the number of requests is higher still. When
          your queue is constantly full, all of this polling is a benefit
          because it allows you to dequeue more quickly, but with our use
          case, there would likely be periods where this is wasteful. If we
          could eliminate that polling entirely, we could potentially make our
          implementation more efficient and reduce latency in the message
          sending process.
        </p>

        <h4>SNS Implementation</h4>

        <p>
          We were able to remove polling from the message sending process by
          using Amazon’s Simple Notification Service, or SNS. SNS is a
          messaging service that, when given an event, sends a message to
          every subscriber to that event. It also automatically handles
          retries. In other words, it does the same job that the combination
          of SQS and messenger lambda previously did for us.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/snsFanout.png" alt="SNS Message Fanout" />
        </div>
        
        <p>
          Rather than use
          polling, SNS uses a pub/sub model where new messages are published
          to topics, and anyone who is subscribed to that topic automatically
          receives a message. In webhook parlance, every consumer that’s
          listening for that event type receives a message.
        </p>

        <p>
          It’s important to note that SNS itself stores subscription data, so
          that’s one more job SNS handles for us that our lambdas were
          previously handling. With SNS, there is no longer a need to pull
          consumer subscriptions when an event comes in - SNS already knows
          who needs to be notified.
        </p>

        <h4>Comparing SQS and SNS</h4>

        <p>
          Switching from SQS to SNS simplifies our architecture and increases
          our efficiency, however there are some tradeoffs with this approach:
        </p>

        <ul>
          <li>
            <p>
              SNS has a max retry delay of 1 hr, compared to SQS’ 12 hrs, so
              it’s got less flexibility to implement large retry windows
            </p>
          </li>
          <li>
            <p>
              Even though SNS keeps track of subscriptions for us, we still
              need subscription data in our main database for querying
              purposes. This means that we now have to keep track of
              subscriptions in two places and make sure they remain identical.
            </p>
          </li>
        </ul>

        <p>
          Both SQS and SNS approaches meet our project goals and both have
          their benefits. In the end we chose SNS because it better fits our
          use case, it removes polling from the message sending process, and
          it includes features like rate limiting and customizable retry logic
          out of the box.
        </p>

        <h3 id="Persisting Message History">6.5. How we persisted message history</h3>

        <h4>SNS to Database Integration</h4>

        <p>
          SNS doesn’t have a built-in way to write message data to our
          database. And in a way, this makes sense - its main job is to fan
          out messages to consumers, and as far as it’s concerned, once it
          delivers a message or makes every effort to, its job is done.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/snsMissingDbLink.png" alt="Missing Link Between SNS and DB" />
        </div>

        <p>
          Our entire event/message lifecycle currently ends the moment SNS
          sends a message to a consumer and receives a response. The only
          thing that’s been saved to our database at that point is the
          original event itself, but no message data has been saved. That
          means no record of who was sent a message and when, what the payload
          was, what response SNS received back, etc. So we needed to find a
          way to get message data from SNS into our database after the
          message send process completed.
        </p>

        <h4>SNS Post-Process</h4>

        <p>
          Our first thought was to see if we could tack on some post-process
          to SNS, like a function that it executes immediately after it
          receives a response back from a consumer. SNS doesn’t have a
          built-in way to do this, but it does allow lambda triggers to be set
          to run whenever a message is published. Inserting lambdas here
          though, would again make lambdas responsible for sending messages to consumers, and at that
          point we’re essentially back at our previous SQS implementation.
          Instead, we found a way to use a service that SNS was already
          integrated with.
        </p>

        <h4>CloudWatch Logs</h4>

        <p>
          SNS stores logging data in Amazon’s CloudWatch Logs service, which
          is commonly used for debugging and a variety of other tasks.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/cloudWatch.png" alt="CloudWatch Logs" />
        </div>

        <p>
          SNS can be configured to log specific events, and in this case we wanted it to log every time it received a response back from a consumer. Using CloudWatch Logs, we now had our persistent message store, but it wasn’t in the same place as the rest of our data, so we needed to find a way to get it from CloudWatch Logs into our main database.
        </p>

        <h4>CloudWatch Logs Lambda Trigger</h4>

        <p>
          CloudWatch Logs can be set up to asynchronously invoke a Lambda
          function, so we set CloudWatch Logs to invoke the lambda when it
          received a new SNS log, and once invoked, the lambda transfers the
          message data in the log to the database.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/finalArchitecture2.png" alt="CloudWatch Logs with Lambda" />
        </div>

        <p>
          In light of these added steps and services, SNS definitely added
          complexity to our architecture in some areas. It still, however,
          abstracted away key functionality in others, and overall we felt
          that its feature set best fit our implementation and provided a few
          additional nice-to-haves out of the box.
        </p>

        <h2 id="FutureWork">7. Future Work</h2>

        <p>
          And that's Tacklebox! We've got a few ideas that we'd love to work
          on moving forward, which could add to its flexibility as a webhook
          service:
        </p>

        <h3 id="ProxyServer">7.1. Proxy Server</h3>

        <p>
          Tacklebox currently does two things by default that, while useful,
          are not features all providers might want:
        </p>

        <ul>
          <li>
            <p>
              It requires consumers to confirm their endpoint, meaning they
              have to verify they are in control of their endpoint before our
              service will send any webhook notifications to them.
            </p>
          </li>
          <li>
            <p>
              It includes AWS metadata in messages sent to consumers that
              isn’t necessarily relevant to Tacklebox
            </p>
          </li>
        </ul>

        <p>
          We could make both of these optional by putting some logic in
          between SNS and consumers. One way we might do that would be to use
          a proxy server, which would handle the auto-confirmations and
          stripping of metadata. But using a typical server would cause us to
          lose some of that uptime efficiency we gained by going with lambdas.
        </p>

        <div class="img-wrapper">
          <img src="images/newDiagrams/proxyServer.png" alt="Proxy Server Implementation" />
        </div>

        <p>
          Speaking of which, we could use lambdas to accomplish this, but as
          we saw in the last section, that extra set of lambdas again adds
          complexity to the architecture for a feature that only a small
          percentage of our users would probably use.
        </p>

        <h3 id="OtherIdeas">7.2. Other Ideas</h3>

        <p>Another few things we’d like to add are:</p>

        <ul>
          <li>
            <p>
              The ability to dynamically set and change settings like retry
              policy and rate limiting on a per-consumer basis.
            </p>
          </li>
          <li>
            <p>
              A consumer UI that potentially allows them to view their own
              message history and do things like resend failed messages
            </p>
          </li>
          <li>
            <p>
              A dead-letter queue for efficient processing of messages that
              still, after the max number of retries, failed to be delivered
              to their consumer endpoint
            </p>
          </li>
          <li>
            <p>
              A feature that detects when a consumer endpoint has passed some
              threshold for successive failures and automatically removes that
              consumer’s subscription from our service
            </p>
          </li>
        </ul>

        <h2 id="References">8. References</h2>
        <div class="footnotes">
          <ol class="footnotes-list">
            <li id="fn1" class="footnote-item">
              <a href="https://api-university.com/books/webhooks/">
                Biehl, M. (2017). Webhooks: Events for RESTful APIs. API-University Press.
              </a>
              <a href="#fnref1">↩︎</a>
            </li>
            <li id="fn2" class="footnote-item">
              <a href="https://launchschool.com/books/working_with_apis/read/defining_api#provider_and_consumer">
                https://launchschool.com/books/working_with_apis/read/defining_api#provider_and_consumer
              </a>
              <a href="#fnref2">↩︎</a>
            </li>
            <li id="fn3" class="footnote-item">
              <a href="https://docs.github.com/en/rest/reference/repos#list-branches">
                https://docs.github.com/en/rest/reference/repos#list-branches
              </a>
              <a href="#fnref3">↩︎</a>
            </li>
            <li id="fn4" class="footnote-item">
              <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#create">
                https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#create
              </a>
              <a href="#fnref4">↩︎</a>
            </li>
            <li id="fn5" class="footnote-item">
              <a href="https://stripe.com/docs/webhooks">
                https://stripe.com/docs/webhooks
              </a>
              <a href="#fnref5">↩︎</a>
            </li>
            <li id="fn6" class="footnote-item">
              <a href="https://developer.twitter.com/en/docs/twitter-api/enterprise/account-activity-api/guides/getting-started-with-webhooks">
                https://developer.twitter.com/en/docs/twitter-api/enterprise/account-activity-api/guides/getting-started-with-webhooks
              </a>
              <a href="#fnref6">↩︎</a>
            </li>
            <li id="fn7" class="footnote-item">
              <a href="https://developer.intuit.com/app/developer/qbo/docs/develop/webhooks">
                https://developer.intuit.com/app/developer/qbo/docs/develop/webhooks
              </a>
              <a href="#fnref7">↩︎</a>
            </li>
            <li id="fn8" class="footnote-item">
              <a href="https://dzone.com/articles/patterns-for-microservices-sync-vs-async">
                https://dzone.com/articles/patterns-for-microservices-sync-vs-async
              </a>
              <a href="#fnref8">↩︎</a>
            </li>
            <li id="fn9" class="footnote-item">
              <a href="https://dzone.com/articles/patterns-for-microservices-sync-vs-async">
                https://dzone.com/articles/patterns-for-microservices-sync-vs-async
              </a>
              <a href="#fnref9">↩︎</a>
            </li>
            <li id="fn10" class="footnote-item">
              <a href="https://www.infoq.com/articles/anatomy-cascading-failure/">
                https://www.infoq.com/articles/anatomy-cascading-failure/
              </a>
              <a href="#fnref10">↩︎</a>
            </li>
            <li id="fn11" class="footnote-item">
              <a href="https://openprairie.sdstate.edu/cgi/viewcontent.cgi?article=4417&context=etd">
                https://openprairie.sdstate.edu/cgi/viewcontent.cgi?article=4417&context=etd
              </a>
              <a href="#fnref11">↩︎</a>
            </li>
            <li id="fn12" class="footnote-item">
              <a href="https://shopify.engineering/circuit-breaker-misconfigured">
                https://shopify.engineering/circuit-breaker-misconfigured
              </a>
              <a href="#fnref12">↩︎</a>
            </li>
            <li id="fn13" class="footnote-item">
              Or until browser timeout, which in the case of Google Chrome, is
              five minutes.
              <a href="#fnref13">↩︎</a>
            </li>
            <li id="fn14" class="footnote-item">
              <a href="https://medium.com/@jeremydaly/serverless-microservice-patterns-for-aws-6dadcd21bc02">
                https://medium.com/@jeremydaly/serverless-microservice-patterns-for-aws-6dadcd21bc02
              </a>
              <a href="#fnref14">↩︎</a>
            </li>
            <li id="fn15" class="footnote-item">
              <a href="https://pragprog.com/titles/mnee2/release-it-second-edition/">
                https://pragprog.com/titles/mnee2/release-it-second-edition/
              </a>
              <a href="#fnref15">↩︎</a>
            </li>
            <li id="fn16" class="footnote-item">
              Latency: the time it takes for data to travel across a network.
              <a href="#fnref16">↩︎</a>
            </li>
            <li id="fn17" class="footnote-item">
              This lines up with Cloudflare’s own testing, which shows
              significant speed increases of Workers compared to Lambda@Edge:
              <a href="https://blog.cloudflare.com/serverless-performance-comparison-workers-lambda/">
                https://blog.cloudflare.com/serverless-performance-comparison-workers-lambda/
              </a>
              <a href="#fnref17">↩︎</a>
            </li>
            <li id="fn18" class="footnote-item">
              <a href="https://shopify.engineering/circuit-breaker-misconfigured">
                https://shopify.engineering/circuit-breaker-misconfigured
              </a>
              <a href="#fnref18">↩︎</a>
            </li>
          </ol>
        </div>
      </section>
    </main>
  </div>

  <footer>
    <div class="footer-backdrop">
      <div class="planet-spacer planet-spacer-bottom"></div>
      <section id="our-team">
        <h1>Our Team</h1>
        <p>
          We are currently looking for opportunities.<br />If you liked what
          you saw and want to talk more, please reach out!
        </p>
        <ul>
          <li class="individual">
            <a href="https://github.com/juanpalma1" target="_blank"><img src="images/team/juan.png"
                alt="Juan Palma" /></a>
            <h3>Juan Palma</h3>
            <p>Phoenix, AZ</p>
            <ul class="social-icons">
              <li>
                <script type="text/javascript" language="javascript">
                  ML = 'e/ioh lr"g<=c.mtad>:b@f';
                  MI = ":@5470F;8>@26?3C40663E9@D7206A0@6>02A@=<3>8B:1@B";
                  OT = "";
                  for (j = 0; j < MI.length; j++) {
                    OT += ML.charAt(MI.charCodeAt(j) - 48);
                  }
                  let arr = OT.split("</a>").slice(0, 1);
                  arr.push(
                    `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                  );
                  document.write(arr.join(""));
                    // -->
                </script>
              </li>
              <li>
                <a href="https://github.com/juanpalma1" target="_blank">
                  <img src="images/icons/website_icon.png" alt="website" />
                </a>
              </li>
              <li>
                <a href="https://www.linkedin.com/in/juanpalma1/" target="_blank">
                  <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                </a>
              </li>
            </ul>
          </li>
          <li class="individual">
            <a href="https://github.com/Kaylthomas777" target="_blank"><img src="images/team/kayl.png"
                alt="John Kayl Thomas" /></a>
            <h3>John Kayl Thomas</h3>
            <p>Atlanta, GA</p>
            <ul class="social-icons">
              <li>
                <script type="text/javascript" language="javascript">
                  ML2 = 's >h"ma@/.elo=ir<:uft';
                  MI2 = "@613?:C=456>;D<A6?D3B?75590D42";
                  OT2 = "";
                  for (j = 0; j < MI2.length; j++) {
                    OT2 += ML2.charAt(MI2.charCodeAt(j) - 48);
                  }
                  let arr2 = OT2.split("</a>").slice(0, 1);
                  arr2.push(
                    `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                  );
                  document.write(arr2.join(""));
                    // -->
                </script>
              </li>
              <li>
                <a href="https://github.com/Kaylthomas777" target="_blank">
                  <img src="images/icons/website_icon.png" alt="website" />
                </a>
              </li>
              <li>
                <a href="https://www.linkedin.com/in/john-kayl-thomas-09a79a113" target="_blank">
                  <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                </a>
              </li>
            </ul>
          </li>
          <li class="individual">
            <a href="https://github.com/counik" target="_blank"><img src="images/team/kevin.png"
                alt="Kevin Counihan" /></a>
            <h3>Kevin Counihan</h3>
            <p>Seattle, WA</p>
            <ul class="social-icons">
              <li>
                <script type="text/javascript" language="javascript">
                  ML3 = ' "<z:>o.irem=cflbhagt@/';
                  MI3 = "2B0A9:><1;B8?D64@38CC3EC;B8?7=6;15";
                  OT3 = "";
                  for (j = 0; j < MI3.length; j++) {
                    OT3 += ML3.charAt(MI3.charCodeAt(j) - 48);
                  }
                  let arr3 = OT3.split("</a>").slice(0, 1);
                  arr3.push(
                    `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                  );
                  document.write(arr3.join(""));
                    // -->
                </script>
              </li>
              <li>
                <a href="https://github.com/counik" target="_blank">
                  <img src="images/icons/website_icon.png" alt="website" />
                </a>
              </li>
              <li>
                <a href="https://www.linkedin.com/in/kevincounihan/" target="_blank">
                  <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                </a>
              </li>
            </ul>
          </li>
          <li class="individual">
            <a href="https://github.com/ArmandoMota" target="_blank"><img src="images/team/armando.png"
                alt="Armando Mota" /></a>
            <h3>Armando Mota</h3>
            <p>Los Angeles, CA</p>
            <ul class="social-icons">
              <li>
                <script type="text/javascript" language="javascript">
                  ML4 = ' "<z:>o.irem=cflbhagt@/';
                  MI4 = "2B0A9:><1;B8?D64@38CC3EC;B8?7=6;15";
                  OT4 = "";
                  for (j = 0; j < MI4.length; j++) {
                    OT4 += ML4.charAt(MI4.charCodeAt(j) - 48);
                  }
                  let arr4 = OT4.split("</a>").slice(0, 1);
                  arr4.push(
                    `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                  );
                  document.write(arr4.join(""));
                    // -->
                </script>
              </li>
              <li>
                <a href="https://github.com/ArmandoMota" target="_blank">
                  <img src="images/icons/website_icon.png" alt="website" />
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/armando-mota-7a8b3092" target="_blank">
                  <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                </a>
              </li>
            </ul>
          </li>
        </ul>
      </section>
    </div>
  </footer>
</body>

</html>