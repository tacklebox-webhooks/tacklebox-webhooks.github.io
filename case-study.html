<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <title>Tacklebox Webhooks as a Service</title>

    <link rel="stylesheet" href="stylesheets/reset.css" />
    <link rel="stylesheet" href="stylesheets/main.css" />

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/icons/favicons/graphic-red.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="images/icons/favicons/graphic-red.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="images/icons/favicons/graphic-red.png"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Red+Hat+Display:ital,wght@0,400;0,700;0,900;1,400&display=swap"
      rel="stylesheet"
    />

    <script type="text/javascript" src="javascripts/sidebar.js"></script>
    <meta property="og:image" content="/images/logos/graphic-red.png" />
    <meta property="og:title" content="Tacklebox" />
    <meta
      property="og:description"
      content="An open-source serverless framework that offers webhooks as a
            service"
    />
  </head>
  <body>
    <header class="header-short">
      <nav>
        <ul>
          <li>
            <a href="index.html">
              <img src="images/logos/graphic-red.png" />
            </a>
          </li>
          <li>
            <a href="index.html">Home</a>
          </li>
          <li><a href="case-study.html" class="active">Case Study</a></li>
          <li><a href="team.html">Our Team</a></li>
          <li class="flex-float-right">
            <a href="https://github.com/tacklebox-webhooks" target="_blank">
              <img
                src="images/logos/github-mark-light.png"
                alt="Tacklebox GitHub"
                class="github"
              />
            </a>
          </li>
        </ul>
      </nav>
    </header>

    <div class="study-wrapper">
      <aside class="sidebar">
        <ul>
          <li>
            <a href="#Introduction"> 1. Introduction</a>
          </li>
          <li>
            <a href="#Intro to Webhooks"> 2. Intro to Webhooks</a>
          </li>
          <li>
            <a href="#Building webhooks is not trivial">
              3. Building webhooks is not trivial</a
            >
          </li>
          <li>
            <a href="#Existing Solutions"> 4. Existing Solutions</a>
          </li>
          <li>
            <a href="#How to use Tacklebox"> 5. How to use Tacklebox</a>
          </li>
          <li>
            <a href="#How we built Tacklebox"> 6. How we built Tacklebox</a>
          </li>
          <li>
            <a href="#Future work"> 7. Future work</a>
          </li>
          <li>
            <a href="#References"> 8. References</a>
          </li>
        </ul>
      </aside>

      <main>
        <section id="case-study">
          <h1>Case Study</h1>

          <h2 id="Introduction">1. Introduction</h2>

          <p>
            The traditional model of service-to-service communication in web
            development can be described as request/response interaction. This
            synchronous model involves a caller sending a request to a receiver,
            waiting on a response from the receiver, and processing the response
            when it is returned. In this model, the caller "asks" the receiver
            to do something.
          </p>

          <p>
            Another model of service-to-service communication is
            <strong>event-based</strong>
            interaction, wherein publishers "announce" events that have already
            happened, and consumers react to those events. In this model,
            neither the publisher or the consumer "asks" the other to do
            anything - the publisher simply announces the event and the consumer
            reacts to it.
          </p>

          <h2 id="Intro to Webhooks">2. Intro to Webhooks</h2>

          <h3 id="What are webhooks">2.1 What are webhooks?</h3>

          <p>
            To understand what webhooks are, let’s begin with an example using a
            tool we all know: GitHub. ​ Imagine you: - are part of a team - have
            one repo for the project the team will work on - want to do
            something programmatically when a branch is created by a teammate,
            like for example, post a message on Slack or something like that. ​
            The flow would look something like this: first, one of your
            teammates creates a new branch locally then, the change is pushed to
            the repo next, the branch is actually created on the repo and
            finally you want to do something programmatically as a result of
            this branch creation.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/githubExample.png"
              alt="What are webhooks"
            />
          </div>

          <p>
            So the question then becomes, how can you automate what you want to
            do once the event happens, which in this case, is a branch being
            created? You basically have two options: Polling and Webhooks.
          </p>

          <p>
            In the context of Web APIs, the party interested in data (which in
            this case, it's you) is called the consumer, and the party that
            provides the data of interest (which in this case, it's GitHub) is
            called the provider.<sup class="footnote-ref"
              ><a href="#fn1" id="fnref1">[1]</a></sup
            >
            With polling, you basically send and HTTP request to GitHub every so
            often to see if there's any updates. In this case, you happen to
            send a couple requests first with no updates from GitHub, and then a
            third one where there's an update.<sup class="footnote-ref"
              ><a href="#fn2" id="fnref2">[2]</a></sup
            >
          </p>
          <div class="img-wrapper">
            <img src="images/diagrams/polling.png" alt="What are webhooks" />
          </div>

          <p>
            With webhooks, however, instead of having GitHub wait for incoming
            requests in order to handle them, now GitHub proactively sends an
            HTTP request to you every time an event you care about occurs. To be
            more specific, GitHub sends an HTTP request to a URL that you
            register with them every time something of interest happens.<sup
              class="footnote-ref"
              ><a href="#fn3" id="fnref3">[3]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/webhooks.png" alt="What are webhooks" />
          </div>

          <p>
            In this particular case, a branch was created, so GitHub sends an
            HTTP request to your endpoint, and you then acknowledge the request.
            In other words, a webhook is nothing more than an HTTP request sent
            when an event happens.
          </p>

          <p>
            Up to this point, we have only talked about webhooks from the
            perspective of the consumer. Now, let's switch gears a little bit to
            talk about webhooks, but from the perspective of the provider, which
            in the example was GitHub. In other words, let's put ourselves in
            GitHub's shoes.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/webhookProviderExample.png"
              alt="What are webhooks"
            />
          </div>

          <p>
            Following the same example, if we're GitHub, and a consumer is
            interested in receiving a webhook every time a branch is created,
            the workflow would look something like this: first, you receive a
            subscription request with a URL to send webhooks to, which would be
            the URL on the right of the slide. This subscription request also
            specifies the event type you'll look out for to send these webhooks,
            which in this case is a branch creation. then, you'll persist the
            subscription after that, a branch is created at some point in time
            then, you check to see who is subscribed to that event type since
            there may be more interested parties. and lastly, you send a webhook
            to the URL of each consumer subscribed to that particular event
            type, which in this case, for simplicity's sake, is just the
            consumer from step one.
          </p>

          <p>
            To show you how webhooks look like in real applications, here's a
            screenshot of the UI GitHub offers for webhooks. Up to the right,
            you can see an "add" button which would be used to request a
            subscription.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/githubExample1.png"
              alt="What are webhooks"
            />
          </div>

          <p>
            After clicking that button, you get to the page where you specify
            the URL where you want to receive webhooks, the event type you're
            interested in, among other things.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/githubExample2.png"
              alt="What are webhooks"
            />
          </div>

          <p>
            And once you register a URL to receive webhooks, you can see all the
            webhooks that GitHub has sent you, their headers, their payload,
            etc.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/githubExample3.png"
              alt="What are webhooks"
            />
          </div>

          <h3 id="Who uses webhooks">2.2 Who uses webhooks?</h3>

          <p>
            So far, when talking about webhooks, we've only talked about GitHub.
            However, it turns out that GitHub is not the only company that
            offers webhooks. Some examples of companies that offer webhooks are:
            Stripe, which can send you a webhook when for example a payment is
            processed Twitter can send you a webhook when for example you
            receive a direct message Intuit, the company that owns products like
            TurboTax and QuickBooks, can send you a webhook for example when a
            budget is created and I mean, I can keep going. The point is,
            webhooks are everywhere.<sup class="footnote-ref"
              ><a href="#fn4" id="fnref4">[4]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/whoUsesWebhooks.png"
              alt="who uses webhooks"
            />
          </div>

          <h3 id="Pros and Cons of building webhooks">
            2.3 Pros and Cons of building webhooks
          </h3>

          <p>
            Now that we have some context around webhooks, we can start talking
            about things to consider when building them. As a provider, webhooks
            offer a few benefits: For example, you can provide a better
            experience to your users that want or need webhooks. And also, you
            can lower the amount of requests your infrastructure needs to handle
            over time. ​ However, webhooks are not perfect: If you want a very
            simple webhooks implementation, it may not take you much. However,
            if you want a robust implementation, you have to spend a lot of time
            and effort building it. And the reason you have to spend a lot of
            time and effort building webhooks well is because building webhooks
            well is not easy. We're going to talk about why building webhooks
            well is not easy in the next section.<sup class="footnote-ref"
              ><a href="#fn4" id="fnref4">[4]</a></sup
            >
          </p>

          <h2 id="Building webhooks is not trivial">
            3. Building webhooks is not trivial
          </h2>

          <h3 id="Considerations when building webhooks">
            3.1 Considerations when building webhooks
          </h3>
          <p>
            Now you, the provider, want to build webhooks in your app. However,
            implementing webhooks well is not as trivial as it may seem at first
            glance. Since we can go down a rabbit hole here, we decided to talk
            about 4 different areas or categories that may present a significant
            amount of challenges. The first area that comes to mind when
            thinking about building webhooks is failed messages. For example: -
            What happens if a consumer URL endpoint fails or is unreachable? -
            Do you try to send the message again? - And if you do, how often and
            how many times do you retry before you stop? ​ The second area that
            comes to mind is security and authentication. For instance: - Do you
            want to make sure the appropriate consumer controls an endpoint
            before you send messages to it? - How do you allow consumers to
            verify the integrity of messages? - How about allowing them to
            verify the origin of messages? The third area revolves around
            monitoring. For example: - How do you identify frequently failing
            endpoints? - How do you monitor historical usage patterns? And last
            but not least we have the area of allowing your consumers to trigger
            events manually for testing or other purposes. In other words,
            consumer experience. For instance: - Do you want to allow your
            consumers to manually trigger events for testing and other purposes?
            - For example, aside from testing, do you want to allow them to
            resend a message manually? - And if you do, how would you implement
            that?
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/considerations.png"
              alt="Considerations when building webhooks"
            />
          </div>

          <h3 id="Building webhooks for a single application">
            3.2 Building webhooks for a single application
          </h3>

          <p>
            In the simplest scenario, building webhooks in one app would look
            something like this. For simplicity, we have two consumers, but
            there could be more. All the questions and areas of concern we have
            would fall into this new webhook implementation we would build in
            this single app.
            <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/considerationsOne.png"
              alt="Considerations when building webhooks"
            />
          </div>

          <h3 id="Building webhooks for multiple applications">
            3.3 Building webhooks for multiple applications
          </h3>

          <p>
            But what if you need webhooks in more than one app? If you need
            webhooks in more than one app, it would look something like this.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/considerationsMulti.png"
              alt="Considerations when building webhooks"
            />
          </div>

          <p>
            Now, you have all the concerns from before times the number of apps.
            ​And on top of that, more questions come up in this scenario. For
            example: - How do you avoid redundant work while implementing and
            maintaining webhooks across all your apps? - How do you make sure
            that webhooks are consistent across all your apps? - And lastly, is
            governance or compliance critical to your apps? and if so, how do
            you enforce control over your data?
          </p>

          <h3 id="Extracting webhooks into a service">
            3.4 Extracting webhooks into a service
          </h3>

          <p>
            At this point, the need for building a robust webhooks
            implementation as its own service becomes clear.<sup
              class="footnote-ref"
              ><a href="#fn6" id="fnref6">[6]</a></sup
            >
            Now, all these concerns are abstracted away by this service, and
            this would give us many benefits. For example: - first, we would
            have a single place to maintain code and add features - also, we
            would have a single place to monitor the service performance and
            other metrics - aside from that, we would have one place where to
            manage related infrastructure - also, we could have consistency
            across all the apps - aside from that, now the apps don’t have to be
            aware of who is consuming their webhooks, allowing more focus on
            business logic - and last but not least, now we would have
            centralized control over data in order to enforce governance or
            compliance if those are important for our apps
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/considerationsExtracted.png"
              alt="Asynchronous Communication"
            />
          </div>

          <h2 id="Existing Solutions">4. Existing Solutions</h2>

          <p>
            So if you’re thinking about implementing a webhooks solution
            yourself, the question that naturally arises is “how do I do that?”.
            Thankfully as we saw earlier, many companies have already
            implemented their own in-house solution and posted their learnings
            online so there are quite a few blueprints out there.
            <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>
          </p>

          <h3 id="In-House solutions">4.1 In-House solutions</h3>

          <p>
            We took particular inspiration from how Square went about
            implementing this feature themselves. They decided to go with AWS
            because it offered the simplest solution thanks to a new feature
            that allowed them to configure Lambdas to pull from Simple Queue
            Service automatically. Some other key features that we liked are: -
            how they used a queue for messages waiting to be sent to subscribers
            - how they used lambdas to dequeue messages and send them to
            subscribers - and how they went about storing successful or failed
            messages in a separate queue or database<sup class="footnote-ref"
              ><a href="#fn8" id="fnref8">[8]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/square.png" alt="In-House solutions" />
          </div>

          <p>
            We also liked Wise Engineering’s webhook service implementation.
            They utilized the SNS (Simple Notification Service) AWS service to
            handle consumer subscriptions. This meant that in regards to: •
            Figuring out which subscriptions need to be notified when an event
            happens • Sending messages to subscribing endpoints when the event
            is triggered • Handling the retrying logic for failed messages. All
            of these operations were extracted from the main app logic and were
            handled by a single service (SNS).<sup class="footnote-ref"
              ><a href="#fn8" id="fnref8">[8]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/wiseEngineering.png"
              alt="In-House solutions"
            />
          </div>

          <h3 id="Commercial and Open Source">
            4.2 Commercial and Open Source
          </h3>

          <p>
            So yea, as we mentioned earlier, trying to build webhooks and
            integrate them even in just one app can be very complex, so as you
            think about trying to expand that out to multiple different apps in
            your ecosystem that can be a very difficult and time consuming thing
            to do. Let’s say for instance that you decide that you don’t want to
            do that because of the complexity and you’d rather off load that to
            a 3rd party provider. Generally, you would have two options, either
            a commercial solution or an open source solution. Unfortunately,
            there currently isn’t an open source solution that provides webhooks
            as a service so that bring us back to considering building a
            solution in-house instead. If you decide to go the commercial route,
            there are a couple of companies that offer Webhooks as a Service.
            The general workflow when using the commercial solutions would be as
            follows: - You, the provider, communicate with their service via API
            calls to set up subscriptions, create event types, send messages
            when an event is triggered, and access message history.<sup
              class="footnote-ref"
              ><a href="#fn8" id="fnref8">[8]</a></sup
            >
          </p>

          <h3 id="Commercial vs. DIY">4.3 Commercial vs. DIY</h3>

          <p>
            The commercial solutions handle the data storage, message sending
            processes to your consumers and general infrastructure management. -
            The trade offs that arise when using commercial solutions would be
            the fact that’d you’d be sharing data with a third party vendor and
            there would be a lack of software customization because it isn’t
            open source. As we saw earlier there are a number of large existing
            companies that offer webhooks to their customers like Github,
            Stripe, Twitter, and Square. They had to build their own solutions
            in-house and manage their own infrastructure but by accepting those
            trade offs, they were able to have control of their data and
            customize their solution to better suit their business needs as they
            change. By examining the pros and cons of each approach we set out
            to create an open source framework that’s easy to deploy and manage.
            And that’s where Tacklebox comes into play.
          </p>

          <div class="img-wrapper">
            <img
              src="images/diagrams/commercialvDIY.png"
              alt="Commercial vs. DIY"
            />
          </div>

          <h3 id="Tacklebox use case">4.4 Tacklebox use case</h3>

          <p>
            So who is Tacklebox geared toward? A good way to find out is to ask
            yourself these 4 questions. 1.) Do you want to be able to easily
            integrate this feature across multiple applications? 2.) Do you want
            to have control over your data? 3.) Are you a small to medium size
            application. 4.) Is your applications core competency anything but
            webhooks? If you answered yes to all of the above questions, then
            Tacklebox would likely be a good fit for you.
          </p>

          <h2 id="How to use Tacklebox">5. How to use Tacklebox</h2>

          <h3 id="Project Goals">5.1 Project Goals</h3>

          <p>
            Make it easy to provide webhooks across multiple applications. Make
            it easy to deploy and manage its infrastructure Make it easy to
            integrate with an application.
          </p>

          <h3 id="Deployment">5.1 Deployment</h3>

          <p>
            To realize the goal of easy deployment, we created our framework in
            such a way that deployment is abstracted to one simple command.
            “Tacklebox deploy”. This process usually takes upwards of 20 minutes
            but is sped up for demo purposes. As you can see here, the output of
            the deployment has two parts: first, the API Host, which is the Base
            URL you'll use to communicate with the Tacklebox API; and second,
            the API Key, which is the key the Tacklebox API uses to authenticate
            you. These two pieces of information are all you need to use our
            client libraries, and you don't have to leave your CLI to retrieve
            them.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/deployment.png" alt="Deployment" />
          </div>

          <h3 id="UI">5.2 UI</h3>

          <p>
            After running tacklebox deploy, you can run the management UI on
            your local server with one command: tacklebox ui. This management UI
            ties back to making it easy to provide webhooks across multiple
            applications. Instead of having to make API calls to figure out the
            KPIs of your webhooks feature for one of your apps, you can just
            view it all in a convenient dashboard
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/uiDeploy.png" alt="Deployment" />
          </div>

          <div class="img-wrapper">
            <img src="images/diagrams/uiDash.png" />
          </div>

          <h3 id="Client libraries">5.3 Client libraries</h3>

          <small>
            To make our framework even easier to manage across your apps, we
            provided client libraries in 4 languages to make using the Tacklebox
            framework standard and DRY.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/clientLibraries.png" />
          </div>

          <h3 id="Tacklebox Demo">5.4 Tacklebox Demo</h3>
          <p>
            Now we are going to show a brief demo of Tacklebox in action. So
            imagine that you’re a software engineer at a consumer electronics
            company and you’re tasked with enabling automatic notifications from
            the purchase order app to several other supply chain apps.
          </p>

          <small>
            The initial workflow when using Tacklebox is to register a service
            by providing the name of it in a JSON body. The service in this case
            is going to be our orderApp. This is the app that is going to be
            providing webhooks.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDemoGif.png" />
          </div>

          <small>
            Now that we have created a service, we can use its ID in the path
            parameters to register an event type that users can subscribe to. In
            this case, we want notifications to be sent whenever a purchase
            order is created. So we’ll call the event type order created.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDemoGif.png" />
          </div>

          <small>
            Next you can create users in order to group their endpoints in one
            place and ensure that they only receive messages intended for them.
            Something to note here as well, is that Users a.k.a, entities that
            are interested in being notified of an event occurrence, can be
            thought of in a few different ways depending on the use case. In our
            example, the users are other supply chain apps like our InvoiceApp
            that want to be notified that a purchase order was created. For
            Github, their users are repositories. For a todo app, the user could
            be the actual user who signed up. Just something to keep in mind
            here.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDemoGif.png" />
          </div>

          <small>
            In the same way that we used the service ID to create event types,
            we can use the user ID to register endpoints. After providing the
            user ID in the path parameters, we also include the url and
            eventTypes that this endpoint will be subscribed to. In this case,
            the InvoiceApp only cares about being notified when a purchase order
            is generated so that is the only event Type that we list here.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDemoGif.png" />
          </div>

          <small>
            So after the initial setup, we can view our management dashboard for
            the service we just registered. Currently we are viewing the
            dashboard for the OrderApp and there’s only one user and one
            endpoint. From here, we are able to view more granular details about
            user, event type, and endpoints that were just created.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDashGif.png" />
          </div>

          <small>
            So here on the left we have our purchase order app and on the right
            we have an endpoint that our user registered for notifications. So
            let’s say a purchase order for 5 computers is created, this triggers
            a message to be sent to the subscribing endpoints which can then
            view the webhook content and take action accordingly.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeEventTriggerGif.png" />
          </div>

          <small>
            So going back to our management dashboard after the triggered event,
            we see the corresponding data has updated accordingly with one event
            being triggered and one message being sent. From here, we are also
            able to view more granular details about the recently triggered
            event as well as the corresponding message that was sent.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/shouldBeDashGif.png" />
          </div>

          <h3 id="Teardown">5.5 Teardown</h3>

          <small>
            If you decide that you no longer need the webhooks feature then you
            can simple remove the infrastructure with one simple command,
            “tacklebox destroy”.
          </small>
          <div class="img-wrapper">
            <img src="images/diagrams/tearDown.png" />
          </div>

          <h2 id="How we built Tacklebox">6. How we built Tacklebox</h2>

          <h2 id="Webhook feature requirements">
            6.1 Webhook feature requirements
          </h2>

          <p>
            Before we can talk about the Tacklebox architecture, it’s important
            to understand the feature requirements for a webhook service. Since
            consolidation is a key part of our use-case, allowing multiple
            applications to use Tacklebox simultaneously was important to us. We
            wanted to allow users to specify event types when creating a new
            webhook subscription. Recalling the Github example, their webhooks
            feature would be less useful if it was an all-or-nothing approach.
            Allowing granular control over these event types is key. Next, we
            wanted to provide easy access to message history. This includes two
            distinct parts: persisting every message sent by Tacklebox (along
            with delivery statuses), and providing an interface to view that
            message history. Finally, we wanted to send messages to consumers
            when events occur. Again, this is the central piece of Tacklebox.
            Without this, it’s not a webhooks service. (As a side note, I want
            to mention that while this message delivery often occurs shortly
            after an event notification is sent to Tacklebox, delivery speed was
            not a primary goal.)
          </p>

          <h2 id="Event / Message lifecycle">6.2 Event / Message lifecycle</h2>

          <p>
            The core functionality of a webhook service is sending messages to
            endpoints when events occur. That process might include the
            following steps: An event occurs in an application, and that
            application notifies the webhook service. The webhook service looks
            at the event type, and gathers a list of subscribers that need to be
            notified The webhook service sends a message to every valid
            subscriber letting them know that an event has occurred. If any
            message delivery fails, the webhook service attempts to resend the
            message until it succeeds or reaches a set number of attempts. Each
            message and its result gets saved to the database, regardless of
            whether it was successful or not.<sup class="footnote-ref"
              ><a href="#fn13" id="fnref13">[13]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/messageLifeCycle.png" />
          </div>

          <h2 id="Tacklebox Architecture">6.3 Tacklebox Architecture</h2>

          <p>
            Now even though we’re going to be focusing almost exclusively on the
            event/message lifecycle as we discuss our architecture moving
            forward, I did want to add a quick comment about how our
            architecture handles basic processes like adding, updating, and
            deleting entities. Generally speaking, almost all of our CRUD
            operations are handled by our intake lambda, and its communication
            with the database. Because of our focus on the event/message
            lifecycle, we’re going to call our database the “message history”
            moving forward, but this is really our store for all persistent
            data, including services, users, event types, etc. There are a few
            processes that require touching both the database and SNS, like
            creating or updating a subscription, and in those cases the lambda
            again orchestrates the process.
            <sup class="footnote-ref"
              ><a href="#fn13" id="fnref13">[13]</a></sup
            >
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/tackleBoxArchitecture.png" />
          </div>

          <h2 id="Challenges">6.4 Challenges</h2>

          <h2 id="Challenges">6.4.1 How we dealt with wasted uptime</h2>

          <p>
            Our initial implementation of Tacklebox used a single application
            server. It could have worked for our use-case, but we saw an
            opportunity to optimize our infrastructure. Webhooks usage patterns
            are often unpredictable and can have moments of high-use as well as
            periods of minimal usage. As a result, with this single app server
            architecture, we may have had a lot of unused compute resources. To
            address this, we decided to use AWS Lambda Functions. - Focus less
            on fact that implementation works, more on the fact that the
            architecture works. Less about our personal implementation and more
            about how architecture in general satisfies requirements.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/whyServerless.png" />
          </div>

          <p>
            Lambda functions, which are AWS’s “Function as a Service” offering,
            allow us to only run code when needed. This also means that you only
            pay for compute that you actually need. Lambdas, of course, come
            with tradeoffs: Cold start times can increase latency - cold start
            time refers to the time it takes to load the function into memory
            before it can be invoked. Stateless, so accessing persistent data
            requires a call to another service Function execution time has a
            limit
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/lambdas.png" />
          </div>

          <p>
            We were ok with these tradeoffs, so we decided to use lambdas. Going
            with lambdas, though, meant that each lambda would have to do all of
            the following tasks every time it runs: They would need to: Intake
            the new event and persist it to db Gather subscriptions and create
            messages for each consumer Send messages to all consumers and wait
            for their responses Write responses to db Respond back to the event
            producer after all of these tasks are done This is a lot of
            responsibility (and potentially a lot of execution time) for a
            single function. So while we believed lambdas improved our
            architecture, they also added some additional challenges we wanted
            to address. To explain these remaining challenges, and how they
            influenced our architecture.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/manyJobs.png" />
          </div>

          <h2 id="Challenges">6.4.2 How we handled message fanout</h2>

          <p>
            The message fan-out process, in particular, is expensive. In our
            current design, when an event comes in a lambda function gets fired
            up and creates a list of messages that need to be sent to each
            consumer listening for that event type. The lambda not only has to
            send the messages, but also has to wait for a response from every
            one before it can finish its work by writing the results to the
            message history. Because webhooks are typically application or
            user-specific, the number of consumers needing to be notified is
            typically low, however there are use cases where the number of
            consumers is high. As the number of consumers increases, so do the
            number of HTTP requests and the probability that one of the
            consumer’s endpoints will fail.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/fanOut.png" />
          </div>

          <p>
            And when we think about consumer endpoints that fail, as in they
            timeout or are unreachable, the burden still lies with the same
            lambda. Retrying failed messages is a key part of a webhook service,
            so in addition to sending its original set of messages, the lambda
            would also need to repeatedly try to resend failed messages before
            it can write to the db and finish. Using exponential backoff, which
            is a common algorithm used in retry logic that increases the amount
            of time between successive retries, means that with every failed
            attempt it will have to run longer until it reaches the maximum
            number of retries or hits lambda’s 15-minute execution time cap.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/retries.png" />
          </div>

          <p>
            We could have added a second type of lambda, which we’ll call a
            messenger lambda, and separated the message creating and message
            sending between them. With this approach, when an event comes in,
            our intake lambda gathers the list of consumers that need messages
            and calls a separate messenger lambda to actually send each message.
            This way, our messenger lambdas can all run at the same time and
            don’t have to wait for each other to finish. Retries would be
            difficult to implement, though, because where do you put messages
            that need to be retried? We could potentially put them in the
            database, but that’s a lot of writing, reading, and deleting for
            data that is really only meant to be temporary. We could also have
            the intake lambda spin up new messenger lambdas for each retry, but
            we’re basically back at our previous implementation and that intake
            lambda is still doing a lot of work. Ideally we’d have another
            service to put those messages into, something truly meant for
            storing temporary data, like a queue. And a queue would have the
            added benefit of centralizing our entire outgoing message list,
            which simplifies debugging, and ensures we pull the messages off to
            send to consumers in-order.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/initialApproach.png" />
          </div>

          <p>
            Amazon’s Simple Queue Service, or SQS for short, does exactly this.
            SQS gives us a reliable place to dump both our original and retried
            messages into, which is great because our intake lambdas can now
            just focus on creating messages for an event. SQS doesn’t send
            messages to consumers itself, so we keep our messenger lambdas
            in-place and continue to use them to send messages. The one
            additional thing they now do is check SQS for new messages, and pull
            them off as soon as they appear. In order to ensure that our
            messenger lambdas continue to only do one thing, we set them up to
            put failed messages back into the queue instead of trying to resend
            them themselves. Some other messenger lambda invocation will pick
            that failed message up at a later time and send it. By adding SQS
            we’ve increased the complexity of our implementation, but each piece
            does fewer things and we’ve sufficiently separated our concerns
            among services suited for their jobs.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/sqs.png" />
          </div>

          <p>
            This is a perfectly reasonable implementation, however we wondered
            if we could eliminate, ironically enough for a webhook service, the
            polling in our architecture. Our messenger lambdas uses polling to
            constantly check SQS to see if new messages have been added. As
            we’ve mentioned, webhook events can be intermittent, and all of
            those polling requests in between events can add up. We could
            potentially make the polling process more efficient by setting the
            messenger lambdas to long-poll and increase the time in between when
            they check for updates, but the tradeoff there is that consumers
            might have to wait longer to receive their messages. With our use
            case that isn’t the worst tradeoff to make, because webhook messages
            typically aren’t needed within sub-second time frames. Still, if we
            could eliminate that polling entirely, we could potentially make our
            implementation even more efficient and reduce latency in the message
            sending process.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/lasers.png" />
          </div>

          <p>
            It’s important to note that SNS itself stores subscription data
            (i.e. which consumers need to be notified of a given event), so
            that’s one more job SNS handles for us that our lambdas were
            previously handling. With SNS, there is no longer a need to hit our
            main database to pull consumer subscriptions when an event comes in
            - SNS already knows who needs to be notified. Switching from SQS to
            SNS simplifies our architecture and removes polling at a key step,
            however there are some tradeoffs with this approach: SNS has a max
            retry delay of 1 hr, compared to SQS’ 12 hrs, so it’s got less
            flexibility to implement large retry windows Because SNS itself
            keeps track of subscriptions, we now have to ensure that the
            subscription data in our main database matches what is in SNS, and
            when changes to subscriptions are made, we have to make the change
            in two places. Likewise, things like adding new event types also
            required double maintenance. Both SQS and SNS approaches meet our
            project goals and both have their benefits, but in the end we chose
            SNS because it better fits our use case, and it included features
            like rate limiting and customizable per-consumer retry logic out of
            the box.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/sns.png" />
          </div>

          <h2 id="Challenges">6.4.3 How we persisted message history</h2>

          <p>
            You may have noticed that in the past SNS slide, there wasn’t a line
            between SNS and our database (aka message history). That’s because
            SNS doesn’t have a built-in way to write message data to our
            database. And in a way, this makes sense - its main job is to fan
            out messages to consumers at every scale, and as far as it’s
            concerned, once it delivers a message or makes every effort to, its
            job is done. So our entire event/message lifecycle currently ends
            the moment SNS sends a message to a consumer and receives a
            response. The only thing that has been saved to our database at that
            point is the original event itself, but no message data has been
            saved. That means no record of who was sent a message and when, what
            the payload was, what response SNS received back, etc. So we needed
            to find a way to get message data from SNS into our message history
            after the message send process completed.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/sns2.png" />
          </div>

          <p>
            Our first thought was to see if we could tack on some post-process
            to SNS, like a function that it executes immediately after it
            receives a response back from a consumer. SNS doesn’t have a
            built-in way to do this. So if we can’t add a function after
            messages have been sent, we could potentially add a function between
            SNS and the consumer, and have that function write to the database.
            We can do this with lambda, however this would definitely add
            complexity because the lambda is again the one sending the message
            to the consumer, and we’re sort of back at our SQS implementation at
            that point. Instead, we found a way to use a service that SNS was
            already integrated with. SNS stores logging data in Amazon’s
            CloudWatch Logs service, which is commonly used for debugging and a
            variety of other tasks. SNS can be configured to log specific
            events, and in this case we wanted it to log when messages received
            responses back from consumers. Using CloudWatch Logs, we did now
            have a persistent message history store, however we ideally wanted
            all of our persistent data to be stored in one database, so we still
            needed to find a way to get it from Cloudwatch Logs into our message
            history.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/sns3.png" />
          </div>

          <p>
            That little bit of compute that was required to get data from
            CloudWatch Logs to Message History can be provided by, yet again, a
            lambda function. CloudWatch Logs can be set up to asynchronously
            invoke a Lambda function when a log of a specific type is written to
            it, so we set CloudWatch Logs to invoke the lambda when it receives
            a new SNS Message Received log type, and once invoked the lambda
            itself transfers the data to the main message history. In light of
            these added steps and services, SNS definitely added complexity to
            our implementation, however as I mentioned we thought that overall
            its feature set best fit our implementation and provided a few
            additional nice-to-haves out of the box. This is the implementation
            we chose in the end, so hopefully you’ve got a bit more context now
            as to how and why we ended up with this architecture.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/sns4.png" />
          </div>

          <h2 id="Future work">7. Future work</h2>

          <h3 id="Proxy Server">7.1 Proxy Server</h3>

          <p>
            Tacklebox currently does two things by default that, while useful,
            are not features all consumers might want: It requires consumers to
            confirm their endpoint, meaning they have to verify they are in
            control of their endpoint before our service will send any webhook
            notifications to them. It includes AWS metadata in messages sent to
            consumers that isn’t necessarily relevant to Tacklebox Because these
            are both feature of SNS itself, and SNS is the piece of our
            infrastructure that communicates directly with consumers, we could
            make both of these optional by putting some logic in between SNS and
            consumers. One way we might do that would be to use a proxy server,
            which would handle auto-confirmations and/or stripping of metadata.
            Using a typical server would of course take us away from our
            serverless goal, so we could also potentially use another layer of
            lambdas instead, but again, we’d be adding more complexity to the
            architecture for a feature that a fairly small percentage of our
            users would use.
          </p>

          <div class="img-wrapper">
            <img src="images/diagrams/proxy.png" />
          </div>

          <h3 id="Other Ideas">7.2 Other Ideas</h3>

          <p>
            Another few things we’d like to add are: The ability to dynamically
            set and change settings like retry policy and rate limiting on a
            per-consumer endpoint basis. A consumer UI that potentially allows
            them to view their own messages history for a particular endpoint
            and do things like resend failed messages A dead-letter queue for
            efficient processing of messages that still, after the max number of
            retries, failed to be delivered to their consumer endpoint A feature
            that detects when a consumer endpoint has passed some threshold for
            successive failures and automatically removes that consumer’s
            subscription from our service
          </p>

          <h2 id="References">8. References</h2>
          <div class="footnotes">
            <ol class="footnotes-list">
              <li id="fn1" class="footnote-item">
                <a href="https://martinfowler.com/bliki/MonolithFirst.html">
                  https://martinfowler.com/bliki/MonolithFirst.html
                </a>
                <a href="#fnref1">↩︎</a>
              </li>
              <li id="fn2" class="footnote-item">
                <a
                  href="https://martinfowler.com/articles/break-monolith-into-microservices.html"
                >
                  https://martinfowler.com/articles/break-monolith-into-microservices.html
                </a>
                <a href="#fnref2">↩︎</a>
              </li>
              <li id="fn3" class="footnote-item">
                <a href="https://martinfowler.com/articles/microservices.html">
                  https://martinfowler.com/articles/microservices.html
                </a>
                <a href="#fnref3">↩︎</a>
              </li>
              <li id="fn4" class="footnote-item">
                <a href="https://martinfowler.com/articles/microservices.html">
                  https://martinfowler.com/articles/microservices.html
                </a>
                <a href="#fnref4">↩︎</a>
              </li>
              <li id="fn5" class="footnote-item">
                <a
                  href="http://msdl.cs.mcgill.ca/people/tfeng/thesis/node38.html"
                >
                  http://msdl.cs.mcgill.ca/people/tfeng/thesis/node38.html
                </a>
                <a href="#fnref5">↩︎</a>
              </li>
              <li id="fn6" class="footnote-item">
                <a
                  href="http://msdl.cs.mcgill.ca/people/tfeng/thesis/node38.html"
                >
                  http://msdl.cs.mcgill.ca/people/tfeng/thesis/node38.html
                </a>
                <a href="#fnref6">↩︎</a>
              </li>
              <li id="fn7" class="footnote-item">
                <a
                  href="https://dzone.com/articles/expecting-failures-in-microservices-and-working-ar"
                >
                  https://dzone.com/articles/expecting-failures-in-microservices-and-working-ar
                </a>
                <a href="#fnref7">↩︎</a>
              </li>
              <li id="fn8" class="footnote-item">
                <a
                  href="https://dzone.com/articles/patterns-for-microservices-sync-vs-async"
                >
                  https://dzone.com/articles/patterns-for-microservices-sync-vs-async
                </a>
                <a href="#fnref8">↩︎</a>
              </li>
              <li id="fn9" class="footnote-item">
                <a
                  href="https://dzone.com/articles/patterns-for-microservices-sync-vs-async"
                >
                  https://dzone.com/articles/patterns-for-microservices-sync-vs-async
                </a>
                <a href="#fnref9">↩︎</a>
              </li>
              <li id="fn10" class="footnote-item">
                <a
                  href="https://www.infoq.com/articles/anatomy-cascading-failure/"
                >
                  https://www.infoq.com/articles/anatomy-cascading-failure/
                </a>
                <a href="#fnref10">↩︎</a>
              </li>
              <li id="fn11" class="footnote-item">
                <a
                  href="https://openprairie.sdstate.edu/cgi/viewcontent.cgi?article=4417&context=etd"
                >
                  https://openprairie.sdstate.edu/cgi/viewcontent.cgi?article=4417&context=etd
                </a>
                <a href="#fnref11">↩︎</a>
              </li>
              <li id="fn12" class="footnote-item">
                <a
                  href="https://shopify.engineering/circuit-breaker-misconfigured"
                >
                  https://shopify.engineering/circuit-breaker-misconfigured
                </a>
                <a href="#fnref12">↩︎</a>
              </li>
              <li id="fn13" class="footnote-item">
                Or until browser timeout, which in the case of Google Chrome, is
                five minutes.
                <a href="#fnref13">↩︎</a>
              </li>
              <li id="fn14" class="footnote-item">
                <a
                  href="https://medium.com/@jeremydaly/serverless-microservice-patterns-for-aws-6dadcd21bc02"
                >
                  https://medium.com/@jeremydaly/serverless-microservice-patterns-for-aws-6dadcd21bc02
                </a>
                <a href="#fnref14">↩︎</a>
              </li>
              <li id="fn15" class="footnote-item">
                <a
                  href="https://pragprog.com/titles/mnee2/release-it-second-edition/"
                >
                  https://pragprog.com/titles/mnee2/release-it-second-edition/
                </a>
                <a href="#fnref15">↩︎</a>
              </li>
              <li id="fn16" class="footnote-item">
                Latency: the time it takes for data to travel across a network.
                <a href="#fnref16">↩︎</a>
              </li>
              <li id="fn17" class="footnote-item">
                This lines up with Cloudflare’s own testing, which shows
                significant speed increases of Workers compared to Lambda@Edge:
                <a
                  href="https://blog.cloudflare.com/serverless-performance-comparison-workers-lambda/"
                >
                  https://blog.cloudflare.com/serverless-performance-comparison-workers-lambda/
                </a>
                <a href="#fnref17">↩︎</a>
              </li>
              <li id="fn18" class="footnote-item">
                <a
                  href="https://shopify.engineering/circuit-breaker-misconfigured"
                >
                  https://shopify.engineering/circuit-breaker-misconfigured
                </a>
                <a href="#fnref18">↩︎</a>
              </li>
            </ol>
          </div>
        </section>
      </main>
    </div>

    <footer>
      <div class="footer-backdrop">
        <div class="planet-spacer planet-spacer-bottom"></div>
        <section id="our-team">
          <h1>Our Team</h1>
          <p>
            We are currently looking for opportunities.<br />If you liked what
            you saw and want to talk more, please reach out!
          </p>
          <ul>
            <li class="individual">
              <a href="https://github.com/juanpalma1" target="_blank"
                ><img src="images/team/juan.png" alt="Juan Palma"
              /></a>
              <h3>Juan Palma</h3>
              <p>Phoenix, AZ</p>
              <ul class="social-icons">
                <li>
                  <script type="text/javascript" language="javascript">
                    ML = 'e/ioh lr"g<=c.mtad>:b@f';
                    MI = ":@5470F;8>@26?3C40663E9@D7206A0@6>02A@=<3>8B:1@B";
                    OT = "";
                    for (j = 0; j < MI.length; j++) {
                      OT += ML.charAt(MI.charCodeAt(j) - 48);
                    }
                    let arr = OT.split("</a>").slice(0, 1);
                    arr.push(
                      `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                    );
                    document.write(arr.join(""));
                    // -->
                  </script>
                </li>
                <li>
                  <a href="https://github.com/juanpalma1" target="_blank">
                    <img src="images/icons/website_icon.png" alt="website" />
                  </a>
                </li>
                <li>
                  <a
                    href="https://www.linkedin.com/in/juanpalma1/"
                    target="_blank"
                  >
                    <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                  </a>
                </li>
              </ul>
            </li>
            <li class="individual">
              <a href="https://github.com/Kaylthomas777" target="_blank"
                ><img src="images/team/kayl.png" alt="John Kayl Thomas"
              /></a>
              <h3>John Kayl Thomas</h3>
              <p>Atlanta, GA</p>
              <ul class="social-icons">
                <li>
                  <script type="text/javascript" language="javascript">
                    ML2 = 's >h"ma@/.elo=ir<:uft';
                    MI2 = "@613?:C=456>;D<A6?D3B?75590D42";
                    OT2 = "";
                    for (j = 0; j < MI2.length; j++) {
                      OT2 += ML2.charAt(MI2.charCodeAt(j) - 48);
                    }
                    let arr2 = OT2.split("</a>").slice(0, 1);
                    arr2.push(
                      `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                    );
                    document.write(arr2.join(""));
                    // -->
                  </script>
                </li>
                <li>
                  <a href="https://github.com/Kaylthomas777" target="_blank">
                    <img src="images/icons/website_icon.png" alt="website" />
                  </a>
                </li>
                <li>
                  <a
                    href="https://www.linkedin.com/in/john-kayl-thomas-09a79a113"
                    target="_blank"
                  >
                    <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                  </a>
                </li>
              </ul>
            </li>
            <li class="individual">
              <a href="https://github.com/counik" target="_blank"
                ><img src="images/team/kevin.png" alt="Kevin Counihan"
              /></a>
              <h3>Kevin Counihan</h3>
              <p>Olympia, WA</p>
              <ul class="social-icons">
                <li>
                  <script type="text/javascript" language="javascript">
                    ML3 = ' "<z:>o.irem=cflbhagt@/';
                    MI3 = "2B0A9:><1;B8?D64@38CC3EC;B8?7=6;15";
                    OT3 = "";
                    for (j = 0; j < MI3.length; j++) {
                      OT3 += ML3.charAt(MI3.charCodeAt(j) - 48);
                    }
                    let arr3 = OT3.split("</a>").slice(0, 1);
                    arr3.push(
                      `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                    );
                    document.write(arr3.join(""));
                    // -->
                  </script>
                </li>
                <li>
                  <a href="https://github.com/counik" target="_blank">
                    <img src="images/icons/website_icon.png" alt="website" />
                  </a>
                </li>
                <li>
                  <a
                    href="https://www.linkedin.com/in/kevincounihan/"
                    target="_blank"
                  >
                    <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                  </a>
                </li>
              </ul>
            </li>
            <li class="individual">
              <a href="https://github.com/ArmandoMota" target="_blank"
                ><img src="images/team/armando.png" alt="Armando Mota"
              /></a>
              <h3>Armando Mota</h3>
              <p>Los Angeles, CA</p>
              <ul class="social-icons">
                <li>
                  <script type="text/javascript" language="javascript">
                    ML4 = ' "<z:>o.irem=cflbhagt@/';
                    MI4 = "2B0A9:><1;B8?D64@38CC3EC;B8?7=6;15";
                    OT4 = "";
                    for (j = 0; j < MI4.length; j++) {
                      OT4 += ML4.charAt(MI4.charCodeAt(j) - 48);
                    }
                    let arr4 = OT4.split("</a>").slice(0, 1);
                    arr4.push(
                      `${`<img src="images/icons/email_icon.png" alt="email" /></a>`}`
                    );
                    document.write(arr4.join(""));
                    // -->
                  </script>
                </li>
                <li>
                  <a href="https://github.com/ArmandoMota" target="_blank">
                    <img src="images/icons/website_icon.png" alt="website" />
                  </a>
                </li>
                <li>
                  <a
                    href="https://linkedin.com/in/armando-mota-7a8b3092"
                    target="_blank"
                  >
                    <img src="images/icons/linked_in_icon.png" alt="linkedin" />
                  </a>
                </li>
              </ul>
            </li>
          </ul>
        </section>
      </div>
    </footer>
  </body>
</html>
